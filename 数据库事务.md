# 事务

### 事务概述  
![img_158.png](img_158.png)    

![img_159.png](img_159.png)   


### ACID
![img_160.png](img_160.png) 

![img_161.png](img_161.png)  


![img_162.png](img_162.png)   
   


### 事务的状态   
![img_163.png](img_163.png)    

![img_164.png](img_164.png)    

![img_165.png](img_165.png)   


### 如何使用事务   
![img_167.png](img_167.png)    
![img_166.png](img_166.png)   
![img_168.png](img_168.png)  
![img_169.png](img_169.png)


![img_170.png](img_170.png)      
![img_171.png](img_171.png)   


隐式提交数据的情况   
![img_172.png](img_172.png)     

![img_173.png](img_173.png)     
![img_174.png](img_174.png)       


### 事务的分类   
![img_176.png](img_176.png)  
![img_177.png](img_177.png)    
![img_175.png](img_175.png)   



上述的一些要点提取：  
默认是自动提交的，如果有BEGIN的话，DML自动提交会失效，DDL不会      
![img_178.png](img_178.png)     

# 事务隔离级别    
![img_179.png](img_179.png)      


### 事务并发问题：    
1. 脏写   
![img_180.png](img_180.png)
![img_181.png](img_181.png)    



2. 脏读   
A读取了B更新但是没有提交的数据   
3. 不可重复读   

![img_182.png](img_182.png)   


4. 幻读
![img_183.png](img_183.png)    
![img_184.png](img_184.png)    

### 隔离级别   
![img_185.png](img_185.png)

![img_187.png](img_187.png)    
Oracle默认是读已提交      
Mysql默认是可重复读    


隔离级别越高并发性能越低       


#### Mysql中的隔离级别    
![img_188.png](img_188.png)  

设置隔离级别   
![img_189.png](img_189.png)    

![img_190.png](img_190.png)      




### 幻读的解决方案   
串行化用了锁，具体在锁和mvcc那边解释   



# 事务日志(redolog undolog)   
![img_191.png](img_191.png)      


![img_192.png](img_192.png)   ![img_193.png](img_193.png)        



redo_log就是每次内存刷盘之前都会先记录在这个真实存在的文件中，这样就算数据库宕机了也能恢复    






![img_194.png](img_194.png)      




![img_195.png](img_195.png)     


![img_196.png](img_196.png)    

![img_197.png](img_197.png)    

3号过程不出事就能保证事务持久性      

![img_199.png](img_199.png)   
![img_198.png](img_198.png)    
0和2实际上丧失了事务ACID的D特性   

![img_200.png](img_200.png)  



### 写入redo log buffer 策略和 redo log file     

###### redo log buffer   
![img_201.png](img_201.png)   
![img_202.png](img_202.png)    

mtr中的操作（log record ）是挨着的，一个事务的多个mtr不一定是挨着的因为各语句可能交替运行的，因为并发   
![img_203.png](img_203.png)    

![img_204.png](img_204.png)   
![img_205.png](img_205.png)    


###### redo log file   
参数设置   
![img_206.png](img_206.png)   
![img_207.png](img_207.png)   


redo log file大小不够存的时候，会涉及到重复利用和扩容的操作   

2. 日志文件组，重复利用的原理     
![img_208.png](img_208.png)     

![img_209.png](img_209.png)    

![img_210.png](img_210.png)    


总结：   
![img_211.png](img_211.png)   